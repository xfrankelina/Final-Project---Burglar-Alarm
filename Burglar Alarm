#include <wiringPi.h>
#include <wiringPiI2C.h>
#include <softTone.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

// I2C Addresses and GPIO Pins
#define LCD_ADDR   0x27
#define ADC_ADDR   0x4B

#define PIR_PIN            27
#define ACTIVE_BUZZER_PIN  26
#define PASSIVE_BUZZER_PIN 12

//Keypad rows, columns, and Map
#define NUM_ROWS 4
#define NUM_COLS 4
int rowPins[NUM_ROWS] = {25, 24, 23, 18};
int colPins[NUM_COLS] = {5, 17, 22, 10};

char keymap[NUM_ROWS][NUM_COLS] = {
    {'D', '#', '0', '*'},
    {'C', '9', '8', '7'},
    {'B', '6', '5', '4'},
    {'A', '3', '2', '1'}
};

//Parameters
#define PIN_CODE           "1295"
#define PIN_MAX_LEN        4
#define TEMP_SAMPLE_CH     0
#define TEMP_BASE_SAMPLES  20
#define TEMP_DELTA_THRESH  15
#define TRIGGER_COUNTDOWN  10

//LCD Control bits
#define LCD_BACKLIGHT 0x08
#define ENABLE        0x04

int lcdFd  = -1;
int adcFd  = -1;

// System State
typedef enum {
    STATE_DISARMED = 0,
    STATE_ARM_PIN_ENTRY,
    STATE_ARMED,
    STATE_TRIGGER_COUNTDOWN,
    STATE_ALARM
} SystemState;

// Timestamp and 911 email simulation
void getTimestamp(char *buf, size_t len) {
    time_t now = time(NULL);
    struct tm *t = localtime(&now);
    strftime(buf, len, "%Y-%m-%d %H:%M:%S", t);
}

void sendNotification(const char *reason) {
    char ts[64];
    getTimestamp(ts, sizeof(ts));

    printf("=== SIMULATED 911 CALL / EMAIL ALERT ===\n");
    printf("[%s] Reason: %s\n", ts, reason);

    FILE *f = fopen("alarm_log.txt", "a");
    if (f) {
        fprintf(f, "[%s] Alarm notification sent. Reason: %s\n", ts, reason);
        fclose(f);
    } else {
        printf("Could not open alarm_log.txt for writing.\n");
    }
}

// LCD help functions

void lcd_toggle_enable(int bits) {
    delayMicroseconds(600);
    wiringPiI2CWrite(lcdFd, bits | ENABLE);
    delayMicroseconds(600);
    wiringPiI2CWrite(lcdFd, bits & ~ENABLE);
    delayMicroseconds(600);
}

void lcd_write_cmd(unsigned char cmd) {
    int highNibble = cmd & 0xF0;
    int lowNibble  = (cmd << 4) & 0xF0;

    wiringPiI2CWrite(lcdFd, highNibble | LCD_BACKLIGHT);
    lcd_toggle_enable(highNibble | LCD_BACKLIGHT);

    wiringPiI2CWrite(lcdFd, lowNibble | LCD_BACKLIGHT);
    lcd_toggle_enable(lowNibble | LCD_BACKLIGHT);
}

void lcd_write_char(unsigned char data) {
    int highNibble = data & 0xF0;
    int lowNibble  = (data << 4) & 0xF0;

    wiringPiI2CWrite(lcdFd, highNibble | 0x01 | LCD_BACKLIGHT);
    lcd_toggle_enable(highNibble | 0x01 | LCD_BACKLIGHT);

    wiringPiI2CWrite(lcdFd, lowNibble | 0x01 | LCD_BACKLIGHT);
    lcd_toggle_enable(lowNibble | 0x01 | LCD_BACKLIGHT);
}

void lcd_init() {
    lcd_write_cmd(0x33);
    lcd_write_cmd(0x32);
    lcd_write_cmd(0x28);
    lcd_write_cmd(0x0C);
    lcd_write_cmd(0x06);
    lcd_write_cmd(0x01);
    delay(5);
}

void lcd_clear() {
    lcd_write_cmd(0x01);
    delay(2);
}

void lcd_set_cursor(int row, int col) {
    int row_offsets[] = {0x80, 0xC0};
    lcd_write_cmd(row_offsets[row] + col);
}

void lcd_print(const char *text) {
    while (*text) {
        lcd_write_char(*text++);
    }
}
void lcd_show_status(const char *line1, const char *line2) {
    lcd_clear();
    lcd_set_cursor(0, 0);
    lcd_print(line1);
    lcd_set_cursor(1, 0);
    lcd_print(line2);
}

// ADS7830 helper

int ads7830_read_raw(int channel) {
    if (channel < 0 || channel > 7) channel = 0;
    int cmd = 0x84 | (channel << 4);
    wiringPiI2CWrite(adcFd, cmd);
    delayMicroseconds(10);
    {
        int value = wiringPiI2CRead(adcFd);
        return value & 0xFF;
    }
}

int temp_get_sample() {
    return ads7830_read_raw(TEMP_SAMPLE_CH);
}

//Keypad Scan
char keypad_get_key() {
    int r, c, k;

    for (c = 0; c < 4; c++) {

        for (k = 0; k < 4; k++) {
            digitalWrite(colPins[k], HIGH);
        }

        digitalWrite(colPins[c], LOW);
        delayMicroseconds(50);

        for (r = 0; r < 4; r++) {
            if (digitalRead(rowPins[r]) == LOW) {
                while (digitalRead(rowPins[r]) == LOW) {
                    delay(10);
                }
                return keymap[r][c];
            }
        }
    }
    return 0;
}

void keypad_init() {
    int r, c;

    for (r = 0; r < 4; r++) {
        pinMode(rowPins[r], INPUT);
        pullUpDnControl(rowPins[r], PUD_UP);
    }

    for (c = 0; c < 4; c++) {
        pinMode(colPins[c], OUTPUT);
        digitalWrite(colPins[c], HIGH);
    }
}

// Buzzers

void buzz_active_beep(int ms) {
    digitalWrite(ACTIVE_BUZZER_PIN, HIGH);
    delay(ms);
    digitalWrite(ACTIVE_BUZZER_PIN, LOW);
}

void buzz_passive_siren(int duration_ms) {
    int elapsed = 0;
    int f;

    while (elapsed < duration_ms) {
        for (f = 800; f <= 2200; f += 50) {
            softToneWrite(PASSIVE_BUZZER_PIN, f);
            delay(5);
            elapsed += 5;
            if (elapsed >= duration_ms) break;
        }
        for (f = 2200; f >= 800; f -= 50) {
            softToneWrite(PASSIVE_BUZZER_PIN, f);
            delay(5);
            elapsed += 5;
            if (elapsed >= duration_ms) break;
        }
    }
    softToneWrite(PASSIVE_BUZZER_PIN, 0);
}
void buzz_short_feedback() {
    buzz_active_beep(80);
}

//Pin Handling
void pin_buffer_clear(char *buf) {
    buf[0] = '\0';
}

void pin_buffer_append(char *buf, char digit) {
    size_t len = strlen(buf);
    if (len < PIN_MAX_LEN) {
        buf[len] = digit;
        buf[len + 1] = '\0';
    }
}

int pin_buffer_check(const char *buf) {
    return strcmp(buf, PIN_CODE) == 0;
}

//Main Code
int main(void) {
    int base = 0;
    int i;
    SystemState state;
    char pinBuf[PIN_MAX_LEN + 1];
    int countdown = 0;
    int lastPIR = LOW;

    printf("Burglar alarm starting...\n");

    if (wiringPiSetupGpio() == -1) {
        printf("wiringPiSetupGpio failed.\n");
        return 1;
    }

    lcdFd = wiringPiI2CSetup(LCD_ADDR);
    if (lcdFd < 0) {
        printf("Failed to init LCD at 0x%02X\n", LCD_ADDR);
        return 1;
    }
    adcFd = wiringPiI2CSetup(ADC_ADDR);
    if (adcFd < 0) {
        printf("Failed to init ADC at 0x%02X\n", ADC_ADDR);
        return 1;
    }

    lcd_init();

    pinMode(PIR_PIN, INPUT);
    pinMode(ACTIVE_BUZZER_PIN, OUTPUT);
    digitalWrite(ACTIVE_BUZZER_PIN, LOW);

    if (softToneCreate(PASSIVE_BUZZER_PIN) != 0) {
        printf("softToneCreate failed on GPIO%d\n", PASSIVE_BUZZER_PIN);
        return 1;
    }
    softToneWrite(PASSIVE_BUZZER_PIN, 0);

    keypad_init();

    for (i = 0; i < TEMP_BASE_SAMPLES; i++) {
        base += temp_get_sample();
        delay(50);
    }
    base /= TEMP_BASE_SAMPLES;
    printf("Baseline temp raw: %d\n", base);

    state = STATE_DISARMED;
    pin_buffer_clear(pinBuf);

    lcd_show_status("DISARMED", "Press A to arm");

    while (1) {
        char key = keypad_get_key();

        //Arm override
        if (key == 'C') {
            state = STATE_DISARMED;
            pin_buffer_clear(pinBuf);
            lcd_show_status("DISARMED", "Press A to arm");
            softToneWrite(PASSIVE_BUZZER_PIN, 0);
            digitalWrite(ACTIVE_BUZZER_PIN, LOW);
            printf("System disarmed via C key.\n");
        }
     switch (state) {
            case STATE_DISARMED:
                if (key == 'A') {
                    lcd_show_status("Enter PIN to", "ARM (then #)");
                    pin_buffer_clear(pinBuf);
                    state = STATE_ARM_PIN_ENTRY;
                    buzz_short_feedback();
                }
                break;

            case STATE_ARM_PIN_ENTRY:
                if (key >= '0' && key <= '9') {
                    size_t j;

                    pin_buffer_append(pinBuf, key);
                    buzz_short_feedback();

                    lcd_set_cursor(1, 0);
                    lcd_print("PIN: ");
                    for (j = 0; j < strlen(pinBuf); j++) {
                        lcd_print("*");
                    }
                } else if (key == '*') {
                    pin_buffer_clear(pinBuf);
                    lcd_show_status("Enter PIN to", "ARM (then #)");
                } else if (key == '#') {
                    if (pin_buffer_check(pinBuf)) {
                        state = STATE_ARMED;
                        lcd_show_status("ARMED", "Monitoring...");
                        buzz_active_beep(200);
                        printf("System ARMED.\n");
                    } else {
                        lcd_show_status("Wrong PIN!", "Try again.");
                        buzz_active_beep(400);
                        pin_buffer_clear(pinBuf);
                        state = STATE_DISARMED;
                        delay(800);
                        lcd_show_status("DISARMED", "Press A to arm");
                    }
                }
                break;

     case STATE_ARMED: {
                int pirVal = digitalRead(PIR_PIN);
                int tempRaw = temp_get_sample();
                int delta = abs(tempRaw - base);
                static unsigned long lastUpdate = 0;
                unsigned long now = millis();
                char buf[17];

                if (now - lastUpdate > 1000) {
                    snprintf(buf, sizeof(buf), "PIR:%d dT:%3d", pirVal, delta);
                    lcd_set_cursor(1, 0);
                    lcd_print("                ");
                    lcd_set_cursor(1, 0);
                    lcd_print(buf);
                    lastUpdate = now;
                }

                if (pirVal == HIGH && lastPIR == LOW) {
                    printf("PIR trigger!\n");
                }
                lastPIR = pirVal;

                if (pirVal == HIGH || delta > TEMP_DELTA_THRESH) {
                    state = STATE_TRIGGER_COUNTDOWN;
                    countdown = TRIGGER_COUNTDOWN;
                    lcd_show_status("INTRUSION!", "Enter PIN to stop");
                    printf("Trigger detected. Countdown started.\n");
                }
                break;
            }

            case STATE_TRIGGER_COUNTDOWN: {
                static unsigned long lastTick = 0;
                unsigned long now = millis();
                char buf[17];

                // Beeps every second and updates countdown
                if (now - lastTick >= 1000) {
                    lastTick = now;
                    snprintf(buf, sizeof(buf), "Alarm in %2d s", countdown);
                    lcd_set_cursor(1, 0);
                    lcd_print("                ");
                    lcd_set_cursor(1, 0);
                    lcd_print(buf);
                    buzz_active_beep(100);
                    countdown--;
                    if (countdown < 0) countdown = 0;
                }
  if (key >= '0' && key <= '9') {
                    pin_buffer_append(pinBuf, key);
                    buzz_short_feedback();
                } else if (key == '*') {
                    pin_buffer_clear(pinBuf);
                } else if (key == '#') {
                    if (pin_buffer_check(pinBuf)) {
                        state = STATE_DISARMED;
                        lcd_show_status("DISARMED", "Press A to arm");
                        buzz_active_beep(300);
                        pin_buffer_clear(pinBuf);
                        printf("Disarmed during countdown.\n");
                    } else {
                        lcd_show_status("Wrong PIN!", "Alarm continues");
                        buzz_active_beep(500);
                        pin_buffer_clear(pinBuf);
                    }
                }

                if (countdown <= 0 && state == STATE_TRIGGER_COUNTDOWN) {
                    state = STATE_ALARM;
                    lcd_show_status("ALARM ACTIVE!", "Enter PIN");
                    sendNotification("Timeout reached after trigger");
                    printf("Alarm ACTIVE.\n");
                }
                break;
            }

            case STATE_ALARM:
                // Continuous siren with pauses to check keypad
                buzz_passive_siren(500);
                buzz_active_beep(200);

                if (key >= '0' && key <= '9') {
                    pin_buffer_append(pinBuf, key);
                    buzz_short_feedback();
                } else if (key == '*') {
                    pin_buffer_clear(pinBuf);
                } else if (key == '#') {
                    if (pin_buffer_check(pinBuf)) {
                        lcd_show_status("DISARMED", "Press A to arm");
                        buzz_active_beep(400);
                        softToneWrite(PASSIVE_BUZZER_PIN, 0);
                        digitalWrite(ACTIVE_BUZZER_PIN, LOW);
                        pin_buffer_clear(pinBuf);
                        state = STATE_DISARMED;
                        printf("Alarm cleared with correct PIN.\n");
                    } else {
                        lcd_show_status("Wrong PIN!", "Alarm stays ON");
                        buzz_active_beep(600);
                        pin_buffer_clear(pinBuf);
                    }
                }
                break;
        }

        delay(50); // small delay to avoid high CPU usage
    }

    return 0;
}
